"""
Java POJO Generator for Drools DRL declared types.

This module parses DRL files to extract 'declare' statements and generates
corresponding Java POJO classes with proper getters/setters for JSON deserialization.
"""

import re
import os
import subprocess
from typing import List, Dict, Tuple


class JavaPojoGenerator:
    """Generates Java POJO classes from Drools DRL declare statements"""

    # Map DRL types to Java types
    TYPE_MAPPING = {
        'String': 'String',
        'int': 'int',
        'Integer': 'Integer',
        'double': 'double',
        'Double': 'Double',
        'boolean': 'boolean',
        'Boolean': 'Boolean',
        'long': 'long',
        'Long': 'Long',
        'float': 'float',
        'Float': 'Float'
    }

    def __init__(self, java_home: str = None):
        """
        Initialize the generator.

        Args:
            java_home: Path to Java installation. If None, uses JAVA_HOME env var.
        """
        self.java_home = java_home or os.getenv('JAVA_HOME', '/usr/lib/jvm/default-java')

    def parse_drl_declares(self, drl_content: str) -> List[Dict]:
        """
        Parse DRL content to extract declare statements.

        Args:
            drl_content: The DRL file content as string

        Returns:
            List of dictionaries containing class information:
            [
                {
                    'name': 'Applicant',
                    'fields': [
                        {'name': 'age', 'type': 'int'},
                        {'name': 'name', 'type': 'String'},
                        ...
                    ]
                },
                ...
            ]
        """
        declares = []

        # Extract package name
        package_match = re.search(r'package\s+([\w.]+)\s*;', drl_content)
        package_name = package_match.group(1) if package_match else 'com.underwriting.rules'

        # Pattern to match declare blocks
        # declare TypeName
        #     field1: Type1
        #     field2: Type2
        # end
        declare_pattern = r'declare\s+(\w+)\s+((?:[^e]|e(?!nd))*?)end'

        for match in re.finditer(declare_pattern, drl_content, re.DOTALL):
            class_name = match.group(1)
            fields_block = match.group(2)

            # Parse fields
            fields = []
            field_pattern = r'(\w+)\s*:\s*([\w.]+)'
            for field_match in re.finditer(field_pattern, fields_block):
                field_name = field_match.group(1)
                field_type = field_match.group(2)

                # Map DRL type to Java type
                java_type = self.TYPE_MAPPING.get(field_type, field_type)

                fields.append({
                    'name': field_name,
                    'type': java_type
                })

            if fields:  # Only add if there are fields
                declares.append({
                    'name': class_name,
                    'package': package_name,
                    'fields': fields
                })

        return declares

    def generate_java_class(self, class_info: Dict) -> str:
        """
        Generate Java POJO source code for a declared type.

        Args:
            class_info: Dictionary with 'name', 'package', and 'fields'

        Returns:
            Java source code as string
        """
        class_name = class_info['name']
        package_name = class_info['package']
        fields = class_info['fields']

        # Start building the class
        java_code = f"""package {package_name};

/**
 * Auto-generated POJO for Drools declared type: {class_name}
 * Generated by JavaPojoGenerator
 */
public class {class_name} implements java.io.Serializable {{

    private static final long serialVersionUID = 1L;

"""

        # Add fields
        for field in fields:
            java_code += f"    private {field['type']} {field['name']};\n"

        java_code += "\n"

        # Add default constructor
        java_code += f"    public {class_name}() {{}}\n\n"

        # Add getters and setters
        for field in fields:
            field_name = field['name']
            field_type = field['type']

            # Capitalize first letter for getter/setter
            capitalized = field_name[0].upper() + field_name[1:] if len(field_name) > 1 else field_name.upper()

            # Getter
            getter_prefix = "is" if field_type == "boolean" else "get"
            java_code += f"    public {field_type} {getter_prefix}{capitalized}() {{\n"
            java_code += f"        return {field_name};\n"
            java_code += f"    }}\n\n"

            # Setter
            java_code += f"    public void set{capitalized}({field_type} {field_name}) {{\n"
            java_code += f"        this.{field_name} = {field_name};\n"
            java_code += f"    }}\n\n"

        # Add toString method
        java_code += "    @Override\n"
        java_code += "    public String toString() {\n"
        java_code += f'        return "{class_name}{{" +\n'
        for i, field in enumerate(fields):
            field_name = field['name']
            if i < len(fields) - 1:
                java_code += f'                "{field_name}=" + {field_name} + ", " +\n'
            else:
                java_code += f'                "{field_name}=" + {field_name} +\n'
        java_code += '                "}";\n'
        java_code += "    }\n"

        # Close class
        java_code += "}\n"

        return java_code

    def generate_and_compile(self, drl_content: str, output_dir: str) -> Tuple[List[str], str]:
        """
        Generate Java POJOs from DRL content, compile them, and return class files.

        Args:
            drl_content: The DRL file content
            output_dir: Directory to output generated files

        Returns:
            Tuple of (list of compiled class file paths, source directory path)
        """
        # Parse declares
        declares = self.parse_drl_declares(drl_content)

        if not declares:
            print("No declare statements found in DRL")
            return [], ""

        # Create directories
        os.makedirs(output_dir, exist_ok=True)
        src_dir = os.path.join(output_dir, 'src')
        classes_dir = os.path.join(output_dir, 'classes')
        os.makedirs(src_dir, exist_ok=True)
        os.makedirs(classes_dir, exist_ok=True)

        java_files = []

        # Generate Java source files
        for class_info in declares:
            package_name = class_info['package']
            class_name = class_info['name']

            # Create package directory
            package_path = os.path.join(src_dir, *package_name.split('.'))
            os.makedirs(package_path, exist_ok=True)

            # Generate Java code
            java_code = self.generate_java_class(class_info)

            # Write to file
            java_file = os.path.join(package_path, f"{class_name}.java")
            with open(java_file, 'w') as f:
                f.write(java_code)

            java_files.append(java_file)
            print(f"Generated Java POJO: {java_file}")

        # Compile Java files
        if java_files:
            print(f"Compiling {len(java_files)} Java files...")
            javac_cmd = [
                os.path.join(self.java_home, 'bin', 'javac'),
                '-d', classes_dir,
                '-source', '1.8',
                '-target', '1.8'
            ] + java_files

            try:
                result = subprocess.run(
                    javac_cmd,
                    capture_output=True,
                    text=True,
                    check=True
                )
                print(f"✓ Compilation successful")
            except subprocess.CalledProcessError as e:
                print(f"✗ Compilation failed:")
                print(f"STDOUT: {e.stdout}")
                print(f"STDERR: {e.stderr}")
                raise Exception(f"Java compilation failed: {e.stderr}")

        # Find all compiled class files
        class_files = []
        for root, dirs, files in os.walk(classes_dir):
            for file in files:
                if file.endswith('.class'):
                    class_files.append(os.path.join(root, file))

        print(f"✓ Generated {len(class_files)} class files")
        return class_files, classes_dir


if __name__ == "__main__":
    # Test the generator
    sample_drl = """
    package com.underwriting.rules;

    declare Applicant
        name: String
        age: int
        creditScore: int
        annualIncome: double
        smoker: boolean
    end

    declare Decision
        approved: boolean
        reason: String
    end
    """

    generator = JavaPojoGenerator()
    declares = generator.parse_drl_declares(sample_drl)

    print("Parsed declares:")
    for decl in declares:
        print(f"  Class: {decl['name']}")
        for field in decl['fields']:
            print(f"    {field['name']}: {field['type']}")

    print("\nGenerated Java code for Applicant:")
    if declares:
        print(generator.generate_java_class(declares[0]))
